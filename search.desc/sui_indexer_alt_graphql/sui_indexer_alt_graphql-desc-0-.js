searchState.loadedDescShard("sui_indexer_alt_graphql", 0, "This type is responsible for the set-up and lifecycle of …\nAdd data to the GraphQL schema that can be accessed from …\nAdd an extension to the GraphQL schema.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAdd an extension as a layer to the axum router.\nReturn a copy of the metrics.\nDo not expose the GraphiQL IDE.\nAdd a handler to the axum router.\nAddress to accept incoming RPC connections on.\nRun the RPC service. This binds the listener and exposes …\nThe GraphQL schema this service will serve, without any …\nSet-up and run the RPC service, using the provided …\nOutput the contents of the default configuration to STDOUT.\nRun the RPC service.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBigtable instance ID to make KV store requests to. If this …\nPath to the RPC’s configuration TOML file. If one is not …\nThe URL of the database to connect to.\nPath to indexer configuration TOML files (multiple can be …\nConfig for an indexer writing to a database used by this …\nBy default, paginated queries will return this many …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConfiguration for health checks.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstraints that the service will impose on requests.\nHow long to wait for a health check to complete before …\nMaximum output size of a disassembled Move module, in …\nMaximum depth of nested field access supported in display …\nMaximumm output size of a display output.\nMaximum budget in bytes to spend when outputting a …\nMaximum nesting allowed in datatype fields when …\nMaximum number of keys that can be passed to a multi-get …\nMaximum number of estimated output nodes in a GraphQL …\nBy default, paginated queries can return at most this many …\nMaximum depth of a GraphQL query that can be accepted by …\nThe maximum number of nodes (field names) the service will …\nMaximum size in bytes of a single GraphQL request, …\nMaximum size in bytes allowed for the <code>txBytes</code> and …\nMaximum amount of nesting among type arguments (type …\nMaximum number of type parameters a type can have.\nMaximum number of datatypes that need to be processed when …\nTime (in milliseconds) to wait for a transaction to be …\nConfigure for SuiNS related RPC methods.\nMaximum (and default) number of object changes that can be …\nMaximum (and default) number of packages that can be …\nPipelines detected as enabled in this indexer …\nTime (in milliseconds) to wait for a read request from the …\nConfiguration for the watermark task.\nHow long to wait between updating the watermark.")