searchState.loadedDescShard("sui_replay_2", 0, "Enum around rpc gql endpoints.\nArguments for replay\nStore implementations for the replay tool.\nUtility to diff <code>TransactionEffect</code> in a human readable …\nTransaction digest to replay.\nFile containing a list of digests, one per line.\nExecution module for replay. The call to the executor …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRPC of the fullnode used to replay the transaction.\nThe output directory for the replay artifacts. Defaults …\nWhether existing artifacts that were generated from a …\nLogical stores needed by the replay tool. Those stores are …\nThis module contains the logic to use transaction data and …\nShow transaction effects.\nSelect which data store mode to use. Options:\nTerminate a batch replay early if an error occurs when …\nWhether to trace the transaction execution. Generated …\nTracing utilities. Mostly deals with directory/file saving …\nPrint a summary of data store usage after the replay …\nThe types of artifacts that the replay tool knows about …\nManages artifacts produced by the replay tool. An …\nEncoding types for artifacts that may be output by the …\nReturns the file for the artifact, including its encoding …\nReturns the string representation of the artifact type.\nEncoding type for each artifact.\nReturns the file extension associated with the encoding …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDeserialize the artifact into json. This should always …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate an <code>ArtifactManager</code> for this artifact type, rooted …\nCreates a new <code>ArtifactManager</code> with the given base path and …\nTry to get the GasUsageReport if the artifact type is …\nTry to get the trace reader if the artifact type is a …\nTry to get the transaction effects if the artifact type is …\nAn implementation of the replay interfaces: …\nFile system implementation of the replay interfaces: …\nGQL Queries Interface to the rpc for the gql schema …\nIn-memory implementation of the replay interfaces: …\nLRU in-memory implementation of the replay interfaces: …\nProvide an implementation of the replay_interface traits …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nFile system implementation of the replay interfaces\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nStatistics about cache usage\nAdd epoch data to the cache\nAdd object data to the cache\nAdd transaction data to the cache\nGet cache statistics\nGet the chain for this store\nClear all caches\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new InMemoryStore with the given node\nGet the node for this store\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new LRU store with default capacities\nCreate a new LRU store with custom capacities\nA read-through store that composes a primary (cache) and a …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new read-through store with primary (cache) and …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>ToString::to_string</code>, but without panic on OOM.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEpoch data required to reaplay a transaction.\nAn <code>EpochStore</code> retrieves the epoch data and protocol …\nWrite-back trait for epoch data. Allows storing epoch …\nQuery for an object. Specifies an <code>ObjectID</code> and the “rule…\nThe <code>ObjectStore</code> trait is used to retrieve objects by their …\nWrite-back trait for object data. Allows storing objects …\nTrait combining all read capabilities for a data store\nTrait combining all read and write capabilities for a data …\nA trait to set up the data store. This is used to setup …\nA reporting trait for data stores to print a usage/summary …\nTransaction data with effects and checkpoint required to …\nA <code>TransactionStore</code> has to be able to retrieve transaction …\nWrite-back trait for transaction data. Allows storing …\nQuery options for an object. <code>Version</code> request an object at …\nReturn the <code>EpochData</code> for a given epoch.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRetrieve objects by their keys, with different query …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn the <code>ProtocolConfig</code> for a given epoch.\nSet up the data store. Returns the chain identifier if …\nGiven a transaction digest, return transaction info …\nStore epoch data for a given epoch.\nStore object data based on the ObjectKey and actual …\nStore transaction data, effects, and the checkpoint it was …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSaves the trace and additional metadata needed to analyze …")